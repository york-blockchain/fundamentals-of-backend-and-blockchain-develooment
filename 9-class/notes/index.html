<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Fundamentals of Backend and Blockchain Development</title>

    <meta name="author" content="Dhruvin Parikh">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="../../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../../reveal.js/css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../../reveal.js/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../../reveal.js/css/print/pdf.css' : '../../reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="../reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->

    <style>
      .reveal .slides h1, .reveal .slides h2, .reveal .slides h3 {
        text-transform: none;
      }

      .two-column {
        display: flex;
        flex-wrap: wrap;
      }

      .two-column em {
        margin: 20px;
      }

      .reveal .big-and-bold {
        font-weight: bold;
        font-size: 135%;
      }

      .reveal .shrunk-a-bit {
        font-size: 90%;
      }

      .reveal .shrunk-a-bit pre {
        width: 100%;
      }

      .reveal pre {
        width: 100%;
      }

      .reveal .highlight {
        color: yellow;
        font-weight: bold;
      }

      .reveal .highlightRed {
        color: red;
        font-weight: bold;
      }

      .left {
        left:-8.33%;
        text-align: left;
        float: left;
        width:50%;
        z-index:-10;
      }

      .right {
        left:31.25%;
        top: 75px;
        text-align: left;
        float: right;
        z-index:-10;
        width:50%;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

<!------------------------------------------------------->



<section data-markdown><script type="text/template">

## CSBC 1000 - Fundamentals of Backend and Blockchain Development

### Class 9: Blockchain & Bitcoin Architecture

*Dhruvin Parikh*

</script></section>


<section data-markdown><script type="text/template">

## Class Plan
* Birth of blockchain technology
* What is blockchain?
* Blockchain nodes, networks and applications
* Distributed ledger technology
* Bitcoin protocol
</script></section>

<section data-markdown><script type="text/template">

## Birth of Blockchain technology

<img src="birth-blockchain.png" style="background-color: white" />
</script></section>

<section data-markdown><script type="text/template">

## Transaction in centralized ledger

<img src="transaction-in-a-centralized-ledger.png">

</script></section>

<section data-markdown><script type="text/template">

## Centralized ledger

<img src="centralized-ledger.png">

</script></section>

<section data-markdown><script type="text/template">

## Blockchain: distributed ledger of transactions

<img src="blockchain-workings-explained.png" width="800">

</script></section>

<section data-markdown><script type="text/template">

## Blockchain
* Peer to peer 
* Group of nodes
* Miners
* Transaction
* Block
* Consensus
* Gas Token
* State
* Smart contract(optional)
    
</script></section>

<section data-markdown><script type="text/template">

## Peer to Peer : Database versus Blockchain

<img src="database-vs-blockchain-arch.jpeg">
</script></section>

<section data-markdown><script type="text/template">

  ## Peer to Peer
  * Nodes use Peer to Peer Network for synchronization.
 <img src="peer-to-peer-network.png">
</script></section>

<section data-markdown><script type="text/template">

## Group of Nodes
* Members of a blockchain network are called Nodes.
</script></section>

<section data-markdown><script type="text/template">

## Miner
* Blockchain miners create Block
<img src="blockchain-works.png" width="700" style="background-color: white" />
</script></section>

<section data-markdown><script type="text/template">

## Transaction
* Enables transition of state.
* By design Eliminates the need for a Centralized Authority to validate transactions by performing peer validations before any transactions
</script></section>

<section data-markdown><script type="text/template">

## Block
* Multiple Blocks make a Blockchain.
* All Blocks in Blockchain are Immutable.
* It ensures the Complete Audit trail of the whole transactions (Verifiability)
</script></section>

<section data-markdown><script type="text/template">

## Consensus
* Consensus - agreement
* The transactions are added to ledger based on Consensus from nodes.
</script></section>

<section data-markdown><script type="text/template">

## Gas Token
* Currency for the transactor to pay towards transition of state.
* A medium to compensate miners for validating a block
</script></section>

<section data-markdown><script type="text/template">

## State
* Each node has the copy of the full ledger.
* history of account balance changes.
</script></section>

<section data-markdown><script type="text/template">

## Smart Contract
* Autonomous code executing agent
</script></section>


<section data-markdown><script type="text/template">

## Block structure

* Decentralized public database that keeps a permanent record of the digital transactions
<img src="bitcoin-blocks.png" style="background-color: white" />
</script></section>

<section data-markdown><script type="text/template">

  ## Storing hashes on-chain
  
  * In some smart contract protocols, a user can commit to a certain value for a file, data-base, etc
  * Because it is expensive to store data on-chain, it is common to hash this value and store only the hash on-chain
    * Uploading the whole file to the chain might be impractical or impossible (may exceed gas block limit)
  
  </script></section>
  
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Validating on-chain hashes
  
  * To get this file, protocol participants must download it from some off-chain system
    * Bittorrent, usenet, freenet, IPFS, secure scuttlebutt, centralized hosting &mdash; whatever
  * The participant does **not** need to trust this off-chain source because they will verify the file against the on-chain hash
    * It is *content addressed*
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Bringing it back on-chain
  
  * But what if a smart contract needs to access the file, or part of it?
  * If it had the file, the smart contract could hash the file and compare the hash
  * But it doesn't, and we have the same problem as before:
    * It's too expensive/impossible to upload the file to the chain
  
  </script></section>
  
  
  
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Quick sidebar: Password storage
  
  * You should never store your users' passwords in plain-text
    * If your database is hacked then they will be exposed
    * This is bad because many users use the same password on multiple sites
  * Instead you should store the output of a password hashing function
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Password hashing functions
  
  * Like regular hash functions, except:
    * Designed to be very slow to compute, so it takes a long time to crack
    * Supports salts
      * A non-secret random value included in the hash to prevent cracking multiple passwords at once, or in advance
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Proof of knowledge
  
  Example unix password DB:
  
  <pre class="hljs js" style="font-size: 45%">
  alice:$2y$10$weUPjZkUXH6gsPt14UcR/uxCoHRVYf4oEe1CdAZTnHq8eM3SzbXsW
  bob:$2y$10$DwIX.8e3sNlh8sMMJzS5P./j0BNtGwejh/dxvTH4TDjmBzoEOpfd.
  carol:$2y$10$xK/m/d4vGlGLylOnQGb/kO4g16aC4S0VrsHOxVcG5zHHO3GQj/vwG
  </pre>
  
  * The DB doesn't store the plain-text passwords
  * But you can verify somebody knows a password by hashing what they provide and comparing to what's in the DB
    * The password they provide is a **proof** they know the password
  
  </script></section>
  
  
  
  
  
  <section>
  
  <p data-markdown>
  ## git
  </p>
  
  <div class="left">
      <img src="git1.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right"><p data-markdown>
  * git stores a tree of *commits*
  * Each commit is hashed and the hash is its *commit id*
  * Each commit references its parent(s) by their hashes
  </p></div>
  
  </section>
  
  
  
  <section>
  
  <div class="left">
      <img src="git2.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right"><p data-markdown>
  * Suppose somebody knows the root node hash *`f910ba..`* and nothing else
  * Let's say we want to prove to them that the "bugfix!!" commit exists in the tree
  </p></div>
  
  </section>
  
  
  
  
  <section>
  
  <div class="left">
      <img src="git3.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right"><p data-markdown>
  * You send them the highlighted commits and they can re-compute the hash themselves to verify
  * The purple is the node you are proving exists
  * The red nodes are called "witnesses"
  </p></div>
  
  </section>
  
  
  
  
  <section>
  
  <p data-markdown>
  ## Verification steps
  </p>
  
  <div class="left">
      <img src="git3.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right" style="font-size: 80%"><p data-markdown>
  1. Hash the bugfix node and verify the "fix tests" witness node includes this hash
  1. Hash the "fix tests" witness and verify the "merge commit" witness includes this hash
  1. Hash the "merge commit" witness and verify the trusted hash matches this hash
  </p></div>
  
  </section>
  
  
  
  <section>
  
  <div class="left">
      <img src="git3.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right"><p data-markdown>
  * Note that the verifier never needed any of the grey nodes to verify the proof
  * If a secure hash function is used, there is no way to modify the "bugfix" commit and use it to make a valid proof
  </p></div>
  
  </section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Review: Trees
  
  <img src="trees.svg" style="background-color: white;" />
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Why trees? Exponential growth
  
  <img src="exponential.svg" style="background-color: white;" />
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Concatenation notation
  
  * For the rest of this talk we will use the `+` operator to indicate concatenation
    * Because javascript does it this way
  * Normally I prefer to use a different operator since addition is commutative but concatenation isn't
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## Merkle trees
  
  * A merkle tree is a tree where each node references its lower nodes by their hashes
    * Often simply called a *hash tree*
  * If somebody knows the root node, we can prove that any node exists by providing a **proof**
    * The proof will include some nodes that the prover isn't interested in but are needed to verify the proof: **witnesses**
  
  </script></section>
  
  
  
  <section data-markdown><script type="text/template">
  
  ## History of Merkle trees
  
  * Invented by Ralph Merkle in late 70s
  * Original purpose was to implement hash-based signatures
    * See the [Signatures Made Simple](https://york-blockchain.github.io/fundamentals-of-backend-and-blockchain-development/6-class/notes/index.html#/25) slide from our cryptography and security class
    * By using Merkle trees, we can make key-pairs that can sign many messages
    * Modern hash-based signatures still use merkle trees, ie XMSS: eXtended Merkle Signature Scheme (RFC 8391)
  
  </script></section>

<section data-markdown><script type="text/template">

## Merkle tree

<img src="merkle-tree.png" style="background-color: white" />
</script></section>

<section data-markdown><script type="text/template">

  ## Proof size
  
  * Because of exponential growth, the number of nodes in our tree grows much faster than the number of levels
    * Each leaf node is a data item
    * Each level increases our proof size by 1 hash (we need a witness at that level)
  * The number of witnesses required grows according to the *logarithm* of the data items
    * Proofs can be small, even for huge numbers of nodes
  
  </script></section>
  
  
  
  
  
  
  
  
  <section>
  
  <p data-markdown>
  ## Verifiable data-base
  </p>
  
  <div class="left">
      <img width="100%" src="merkle1.svg" style="float: left; border:0px; background-color: white" />
  </div>
  
  <div class="right"><p data-markdown>
  * A merkle tree is a way of structuring a data-base so it can be verified with proofs
  * Here is a DB with 8 elements in it
  * 3 bit paths required, because:
    * log2(8) = 3
  </p></div>
  
  </section>

<section data-markdown><script type="text/template">

  ## Simplified Payment Verification
  
  * In Bitcoin it is possible to verify a transaction has been included in the blockchain without downloading all the blocks
  * Only need the block headers of the longest chain
    * Keep asking nodes until you are sure you have longest chain
    * Get someone who has the full chain to generate you a merkle proof
      * Electrum servers can do this
  
  </script></section>

<section data-markdown><script type="text/template">

  ## 15 minute break
  
  </script></section>
    
    
<section data-markdown><script type="text/template">

## Simplified Payment Verification

<img src="spv.svg" style="background-color: white;" />

</script></section>
    
    
    
    
    <section>
    
    <p data-markdown>
    ## Certificate transparency
    </p>
    
    <div class="left">
        <img width="100%" src="certtrans.png" style="float: left; border:0px; background-color: white" />
    </div>
    
    <div class="right"><p data-markdown>
    * Project that tries to keep SSL Certificate Authorities honest
    * So they can't sign SSL certificates for spy agencies without getting caught
    </p></div>
    
    </section>
    
    
    
    
    <section>
    
    <p data-markdown>
    ## Merkle Patricia Trie
    </p>
    
    <div class="left">
        <img width="100%" src="trie.png" style="float: left; border:0px; background-color: white" />
    </div>
    
    <div class="right"><p data-markdown>
    * Merkle Patricia Trie is a way to efficiently handle *sparse* paths, like the output of hash functions
    * First implemented in Ripple, popularised by Ethereum
    </p></div>
    
    </section>
    
    
    
    
    
    
  <section data-markdown><script type="text/template">
  
  ## Air-drops
  
  * Some token creators want to give their tokens an initial distribution by giving them away
    * Usually to every address that held ETH at a certain block height
  * This is why you may see unknown (usually worthless) tokens appear in your wallet sometimes
  
  </script></section>
    
    
    
    
  <section data-markdown><script type="text/template">
  
  ## Air-drops: Impossible way
  
  * When creating the token contract, pass the list of addresses and their initial token balances in to the constructor
  * Won't work because there could be millions of addresses
    * Can't fit that much data in a block (exceeds block gas limit)
  
  </script></section>
    
    
    
  <section data-markdown><script type="text/template">
  
  ## Air-drops: Inefficient way
  
  * After creating the token contract, send transactions transferring tokens to each address
  * Requires spamming the network with many transactions
    * Costs lots of ETH in gas
    * Wasteful: Most recipients don't even care about these tokens!
  
  </script></section>
    
    
    
    
  <section data-markdown><script type="text/template">
  
  ## Air-drops: Better way
  
  * Use a merkle tree to commit to the initial balances
  * Recipients can submit a proof to claim their tokens
    * The contract creator doesn't pay any gas for the distribution
    * Only people who care about their tokens need to pay gas
  
  </script></section>

<section data-markdown><script type="text/template">

## Consensus

* Need for consensus
* Two general's problem
* Byzantine Generals Problem
</script></section>

<section data-markdown><script type="text/template">

## CAP Theorem

* CAP Theorem states that all distributed systems can only have two of the three properties at any time. 
 * Consistency
 * Availability
 * Partition tolerance
</script></section>

<section data-markdown><script type="text/template">

## Consistency

* A network has Consistency when all its peers are able to provide the current state without disagreeing on what this state is. 
* If it does not have the most recent state, it will not provide any response. 
* In a consistent system, no two nodes return states that are outdated and different from each other. 
* If there is a discrepancy between the states retrieved from each node, the system returns an error. 
* This ensures a safety representation of data to clients.
</script></section>

<section data-markdown><script type="text/template">

## Availability

* Distributed system has Availability when all nodes are able to perform read and write operations without delay. 
* The network is “live” because it allows clients to fetch and store data at any time. 
* This ignores correctness of the state and focuses on user experience. 
* This means that although the responses are successful, it is possible to receive an incorrect state. 
</script></section>

<section data-markdown><script type="text/template">

## Partition tolerance

* When two or more peers in a network are disconnected from each other, there is a partition (think of this in terms of graph theory where a node is a vertice and connections to other nodes are edges). 
* A network has Partition tolerance when it is able to operate despite its partitions.
</script></section>

<section data-markdown><script type="text/template">

## How bitcoin work?
    
</script></section>


<section data-markdown><script type="text/template">

## Public key cryptography

<img src="pkey.png" style="background-color: white; width:600px" />
</script></section>


<section data-markdown><script type="text/template">

## Encrypted message sending

<img src="message.png" style="background-color: white; width:500px" />
</script></section>

<section data-markdown><script type="text/template">

## Double spending issue

<img src="double-spending.png" style="background-color: white; width:500px" />
</script></section>

<section data-markdown><script type="text/template">

## Solution to double spending issue

<img src="double-spent-solution.png" style="background-color: white; width:400px" />
</script></section>

<section data-markdown><script type="text/template">

## Hash function features

* Deterministic
* Quickly compute the hash value for any given message.
* Impossible to reverse the process that generated the given hash value
* Impossible to find two different messages with the same hash value
* Structured

</script></section>

<section data-markdown><script type="text/template">

## Hashing of timestamped transactions

<img src="timestamp-hash.png" style="background-color: white; width:600px" />

</script></section>

<section data-markdown><script type="text/template">
## Bitcoin blockchian explorer
* https://www.blockchain.com/explorer/blocks/btc/
* [Genesis Block](https://www.blockchain.com/explorer/blocks/btc/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f)
</script></section>

<section data-markdown><script type="text/template">
## Proof-Of-Work Algorithm
<img src="proof-of-work-bitcoin-implementation.png" width="600">
</script></section>

<section data-markdown><script type="text/template">

## Hash-based Proof-of-work

<img src="hash-pow.png" style="background-color: white; width:600px" />

</script></section>


<section data-markdown><script type="text/template">

## Bitcoin transactions

<img src="bitcoin-tx.png" style="background-color: white; width:600px" />

</script></section>

<section data-markdown><script type="text/template">

## Bitcoin transaction steps

* Create a hash of the previous transaction and the public key of the next owner.
* Add this hash to the end of the coin.

<img src="bitcoin-txs.png" style="background-color: white; width:300px" />

</script></section>

<section data-markdown><script type="text/template">

## Timestamp server

<img src="timestamp-server.png" style="background-color: white; width:400px" />

</script></section>

<section data-markdown><script type="text/template">

## UTXO model

* 100,000,000 satoshi == 1 BTC

<img src="utxo.png" style="background-color: white; width:600px" />

</script></section>

<section data-markdown><script type="text/template">

## Assessment

* Module 9 : Blockchain And bitcoin architecture quiz
    
</script></section>

<section data-markdown><script type="text/template">
## References
* [Blockchain fundamentals](https://ajithp.com/2018/02/01/block-chain-fundamentals/)
* [Build own blockchain architecture](https://mlsdev.com/blog/156-how-to-build-your-own-blockchain-architecture)
</script></section>


<section data-markdown><script type="text/template">

## End of Class

</script></section>


<!------------------------------------------------------->


      </div>

    </div>

    <script src="../../reveal.js/lib/js/head.min.js"></script>
    <script src="../../reveal.js/js/reveal.js"></script>
    <script src="../../reveal.js/plugin/zoom-js/zoom.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'none', // none/fade/slide/convex/concave/zoom

	math: {
          mathjax: '../lib/MathJax/MathJax.js',
          config: 'TeX-AMS_SVG-full',
	},

        // Optional reveal.js plugins
        dependencies: [
          { src: '../../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../../reveal.js/plugin/math/math.js', async: true }
        ]
      });

    </script>

  </body>
</html>